type Order {
  # Decided chefId and customerId won't resolve to user info
  _id: ID!
  chefId: ID!
  customerId: ID!
  cart: [Dish!]!
  status: OrderStatus!
  date: String!
  cashTotal: Int!
  orderInstructions: String!
}

 # OrderStatus codes/messages
  # 0: "Pending"
  # 1: "Accepted"
  # 2: "Completed"
  # 3: "Canceled"
  # 4: "Reviewed"

type OrderStatus {
  statusCode: Int!
  statusMessage: String!
}

input OrderStatusInput {
  statusCode: Int!
  statusMessage: String!
}

input DishInput {
  dishId: ID!
  orderCount: Int!
}

# New incoming order should have cart array of dishIDs.
input IncomingOrder {
  chefId: ID!
  customerId: ID!
  cart: [DishInput!]!
  status: OrderStatusInput!
  # date on IncomingOrder is optional, default set by Database.
  date: String
  orderInstructions: String!
}

extend type Query {
  # callerType of 'Customer' or 'Chef' determines whether to use callerID to query chefId or customerId in DB schema
  getOrdersByStatus(callerID: ID!, callerType: String!, statusCode: Int!): [Order]! 
}

extend type Mutation {
  """
  Server takes incoming dishIDs from cart and tabulates cashTotal in postNewOrder.

  For Orders, there is a one to one mapping between a User and a Chef. A User's Order will never have dishes from other local Chefs in the neighborhood. 

  Frontend is responsible for ensuring never to send Dishes whose quantity is 0 for new orders.

  
  """
  postNewOrder(incomingOrder: IncomingOrder!): [Order]!

  
  updateOrder(orderID: ID!, statusCode: Int!): [Order]!
}


 # OrderStatus codes/messages
  # 0: "Pending"
  # 1: "Accepted"
  # 2: "Completed"
  # 3: "Canceled"
  # 4: "Reviewed"

# Todo: Implement Socket.io
# socket.io: alertChef
# socket.io: alertCustomer
