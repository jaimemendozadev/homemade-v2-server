type Order {
  # Decided chefId and customerId won't resolve to user info
  _id: ID!
  chefId: ID!
  customerId: ID!
  cart: [Dish!]!
  status: OrderStatus!
  date: String!
  cashTotal: Int!
  orderInstructions: String!
}

 # OrderStatus codes/messages
  # 0: "Pending"
  # 1: "Accepted"
  # 2: "Completed"
  # 3: "Canceled"
  # 4: "Reviewed"

type OrderStatus {
  statusCode: Int!
  statusMessage: String!
}

input OrderStatusInput {
  statusCode: Int!
  statusMessage: String!
}

# New incoming order should have cart array of dishIDs and tabulated cash order
input IncomingOrder {
  chefId: ID!
  customerId: ID!
  cart: [ID!]!
  status: OrderStatusInput!
  # date on IncomingOrder is optional, default set by Database.
  date: String
  cashTotal: Int!  
  orderInstructions: String!
}

extend type Query {
  # callerType of 'Customer' or 'Chef' determines whether to use callerID to query chefId or customerId in DB schema
  getOrdersByStatus(callerID: ID!, callerType: String!, statusCode: Int!): [Order]! 
}

extend type Mutation {
  # status corresponds to orderInstructions in DB schema
  postNewOrder(incomingOrder: IncomingOrder!): [Order]!
  updateOrder(orderID: ID!, statusCode: Int!): [Order]!
}


 # OrderStatus codes/messages
  # 0: "Pending"
  # 1: "Accepted"
  # 2: "Completed"
  # 3: "Canceled"
  # 4: "Reviewed"

# Todo: Implement Socket.io
# socket.io: alertChef
# socket.io: alertCustomer
