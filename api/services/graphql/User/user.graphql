type User {
  authId: String
  firstName: String!
  lastName: String!
  bio: String
  status: String
  phoneNumber: String!
  likes: [Int]
  profileUrl: String
  # customerReviews: []
  # chefReviews: []
  isChef: Boolean
  chefDishes: [Dish]
  location: Location
  address: String!
  rating: Int
  signatureURL: String
  email: String!
}



input UserPayload {
  authId: String
  firstName: String!
  lastName: String!
  bio: String
  status: String
  phoneNumber: String!
  likes: [Int]
  profileUrl: String
  # customerReviews: []
  # chefReviews: []
  isChef: Boolean
  # location: LocationInput
  address: Address
  rating: Int
  signatureURL: String
  email: String!
}

type Location {
  geo_lat: Int,
  geo_lng: Int,
}

input LocationInput {
  geo_lat: Int,
  geo_lng: Int,
}

type Address {
  streetNumber: String,
  city: String,
  state: String,
  postalCode: String
}

type Query {
  getUser(authID: String!): User!
  getChefReviews(authID: String!): [String]!
  getUserReviews(authID: String!): [String]!
  
  # getChefDetails is similiar to getUser, might delete
  getChefDetails(authID: String!): [User]!
  findChefsInRange(input: LocationInput): [User]!
  # findChefsByStyle filters by both location and cuisineType
  findChefsByStyle(input: LocationInput, cuisineType: String!): [User]!
}

type Mutation {
  createUser(input: UserPayload!): [User]!
  updateUser(authID: String!): [User]!
  addSignature(authID: String!): String!
  postUserReview(authID: String!): [String]!
  postChefReview(authID: String!): [String]!
}

# ToDo: Possibly Implement Twilio
# Twilio: textChef
